using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AdventOfCode.SourceGenerator;

[Generator]
public class PuzzleSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes that implement IPuzzle
        var puzzleClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsPuzzleCandidate(s),
                transform: static (ctx, _) => GetPuzzleInfo(ctx))
            .Where(static m => m is not null);

        // Collect all puzzle classes and generate the static list
        var compilation = context.CompilationProvider.Combine(puzzleClasses.Collect());

        context.RegisterSourceOutput(compilation, static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    private static bool IsPuzzleCandidate(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration &&
               classDeclaration.BaseList?.Types.Count > 0;
    }

    private static PuzzleInfo? GetPuzzleInfo(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);

        if (symbol is not ITypeSymbol typeSymbol)
            return null;

        // Check if the class implements IPuzzle
        var iPuzzleInterface = typeSymbol.AllInterfaces.FirstOrDefault(i =>
            i.Name == "IPuzzle" && i.ContainingNamespace.ToDisplayString() == "AdventOfCode.Solutions");

        if (iPuzzleInterface is null)
            return null;

        // Extract year and day from namespace
        var fullNamespace = symbol.ContainingNamespace.ToDisplayString();
        var yearMatch = System.Text.RegularExpressions.Regex.Match(fullNamespace, @"Year(\d{4})");
        var className = symbol.Name;
        var dayMatch = System.Text.RegularExpressions.Regex.Match(className, @"Day(\d{2})");

        if (!yearMatch.Success || !dayMatch.Success)
            return null;

        var year = int.Parse(yearMatch.Groups[1].Value);
        var day = int.Parse(dayMatch.Groups[1].Value);

        // Get description from DescriptionAttribute
        var descriptionAttribute = symbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "DescriptionAttribute");

        var description = descriptionAttribute?.ConstructorArguments.FirstOrDefault().Value?.ToString() ?? "Unknown";

        return new PuzzleInfo
        {
            FullTypeName = symbol.ToDisplayString(),
            Year = year,
            Day = day,
            Description = description
        };
    }

    private static void Execute(Compilation compilation, IEnumerable<PuzzleInfo?> puzzles, SourceProductionContext context)
    {
        var validPuzzles = puzzles.Where(p => p is not null).OrderBy(p => p!.Year).ThenBy(p => p!.Day).ToList();

        if (validPuzzles.Count == 0)
            return;

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine();
        sb.AppendLine("namespace AdventOfCode.Solutions;");
        sb.AppendLine();
        sb.AppendLine("public static partial class PuzzleRegistry");
        sb.AppendLine("{");
        sb.AppendLine("    private static readonly List<PuzzleContainer> _allPuzzles = new()");
        sb.AppendLine("    {");

        foreach (var puzzle in validPuzzles)
        {
            if (puzzle is null) continue;

            sb.AppendLine($"        new PuzzleContainer");
            sb.AppendLine($"        {{");
            sb.AppendLine($"            Puzzle = new {puzzle.FullTypeName}(),");
            sb.AppendLine($"            Year = {puzzle.Year},");
            sb.AppendLine($"            Day = {puzzle.Day},");
            sb.AppendLine($"            Name = \"{EscapeString(puzzle.Description)}\"");
            sb.AppendLine($"        }},");
        }

        sb.AppendLine("    };");
        sb.AppendLine();
        sb.AppendLine("    public static IReadOnlyList<PuzzleContainer> AllPuzzles => _allPuzzles;");
        sb.AppendLine();
        sb.AppendLine("    public static IEnumerable<PuzzleContainer> GetPuzzles(int year, int? day)");
        sb.AppendLine("    {");
        sb.AppendLine("        return _allPuzzles");
        sb.AppendLine("            .Where(p => p.Year == year && (day == null || p.Day == day.Value));");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource("PuzzleRegistry.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static string EscapeString(string str)
    {
        return str.Replace(@"\", @"\\").Replace(@"""", @"\""");
    }

    private class PuzzleInfo
    {
        public string FullTypeName { get; set; } = "";
        public int Year { get; set; }
        public int Day { get; set; }
        public string Description { get; set; } = "";
    }
}

